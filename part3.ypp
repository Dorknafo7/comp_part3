%{
    #include <stdio.h>
    #include "part3_helpers.hpp"
    #include <cassert>
    
    int main(int argc, char* argv[]);
    void yyerror(const char* c);
    void semanticError(string str);

    void handleSymbolDcl(string name, Type type);
    void handleExpRelopExp(string opcode_without_type, string opcode_breqz_bneqz, int exp1_regnum, int exp2_regnum, Type type, vector<int>& true_list, vector<int>& false_list);
    void printRunTimeError();
    bool compFunctions(const Function& func, Type return_type, vector<Type> param_types = {}, vector<string> param_ids = {});

    extern int yylex();
    extern char *yytext;
    extern int yylineno;

    void DBG(string str);
    void DbgPrintAllFunctions();
%}

%token token_int
%token token_float
%token token_void
%token token_write
%token token_read
%token token_va_arg
%token token_while
%token token_do
%token token_return
%token token_id
%token token_integernum
%token token_realnum
%token token_str
%token token_ellipsis
%nonassoc token_if token_then
%nonassoc token_else
%right token_assign
%left token_or
%left token_and
%left token_relop
%left token_addop
%left token_mulop
%right token_not
%left ','
%left '('
%left ')'
%left '{'
%left '}'
%left ':'
%left ';'

%%

PROGRAM: FDEFS
         {
            // backpatch the calling lines as now we know the definition lines of the defined functions.
            for (const auto& pair : functionTable) {
                buffer->backpatch(pair.second.callingLines, pair.second.startLineImplementation);
            }
         }
;

FDEFS : FDEFS FUNC_DEF_API BLK
        {
            symbolTable.clear();
            function_arguments.clear();
            current_stack_pointer = 0;
            current_block_depth   = 0;
            next_int_register     = 3;
            next_float_register   = 3;
            current_func_variadic = false;

            buffer->emit("RETRN");
        }
        |
        FDEFS FUNC_DEC_API 
        {
            function_arguments.clear();
            symbolTable.clear();
        }
        |
        /*epsilon*/
        {

        }
;

FUNC_DEC_API : TYPE token_id '(' M ')' ';'
               {
                    if (functionTable.find($2.name) != functionTable.end()) {
                        if (!compFunctions(functionTable.at($2.name), $1.type)) {
                            semanticError("Function overloading is not supported");
                        }
                    }
                    else {
                        // New function. Add to the functionTable
                        Function new_func;
                        new_func.returnType               = $1.type;
                        new_func.isDefined                = false;
                        new_func.startLineImplementation  = -1;
                        new_func.startIndexOptionalParams = -1;
                        functionTable[$2.name]            = new_func;
                    }
               }
               |
               TYPE token_id '(' M FUNC_ARGLIST ')' ';'
               {
                    if (functionTable.find($2.name) != functionTable.end()) {
                        vector<string> param_ids;
                        vector<Type> param_types;
                        for (auto arg : function_arguments) {
                            param_types.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            param_ids.push_back(arg);
                        }
                        if (!compFunctions(functionTable.at($2.name), $1.type, param_types, param_ids)) {
                            semanticError("Function overloading is not supported");
                        }
                    }
                    else {
                        // New function. Add to the functionTable
                        Function new_func;
                        for (auto arg : function_arguments) {
                            new_func.paramTypes.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            new_func.paramIds.push_back(arg);
                        }
                        new_func.returnType               = $1.type;
                        new_func.isDefined                = false;
                        new_func.startLineImplementation  = -1;
                        new_func.startIndexOptionalParams = -1;
                        functionTable[$2.name]            = new_func;
                    }
               }
               |
               TYPE token_id '(' M FUNC_ARGLIST ',' token_ellipsis ')' ';'
               {
                    if (functionTable.find($2.name) != functionTable.end()) {
                        vector<string> param_ids;
                        vector<Type> param_types;
                        for (auto arg : function_arguments) {
                            param_types.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            param_ids.push_back(arg);
                        }
                        if (!compFunctions(functionTable.at($2.name), $1.type, param_types, param_ids)) {
                            semanticError("Function overloading is not supported");
                        }
                    }
                    else {
                        // New function. Add to the functionTable
                        Function new_func;
                        for (auto arg : function_arguments) {
                            new_func.paramTypes.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            new_func.paramIds.push_back(arg);
                        }
                        new_func.returnType               = $1.type;
                        new_func.isDefined                = false;
                        new_func.startLineImplementation  = -1;
                        new_func.startIndexOptionalParams = function_arguments.size();
                        functionTable[$2.name]            = new_func;
                    }
               }
;

FUNC_DEF_API : TYPE token_id '(' M ')' 
               {
                    if (functionTable.find($2.name) != functionTable.end()) {
                        // Function is already defined/declared.
                        if (functionTable[$2.name].isDefined) {
                            semanticError("Redefinition of function \"" + $2.name +"\"");
                        }
                        // else the function is already declared but not defined.
                        if (!compFunctions(functionTable.at($2.name), $1.type)) {
                            semanticError("Function overloading is not supported");
                        }
                        functionTable[$2.name].startLineImplementation = $4.quad;
                        functionTable[$2.name].isDefined               = true;

                    }
                    else {
                        // New function. Add to the functionTable
                        Function new_func;
                        new_func.returnType               = $1.type;
                        new_func.startLineImplementation  = $4.quad;
                        new_func.isDefined                = true;
                        new_func.startIndexOptionalParams = -1;
                        functionTable[$2.name]            = new_func;
                    }
                    current_return_type = $1.type;
               }
               |
               TYPE token_id '(' M FUNC_ARGLIST ')'
               {
                    if (functionTable.find($2.name) != functionTable.end()) {
                        // Function is already defined/declared.
                        if (functionTable[$2.name].isDefined) {
                            semanticError("Redefinition of function \"" + $2.name +"\"");
                        }
                        // else the function is already declared but not defined.
                        vector<string> param_ids;
                        vector<Type> param_types;
                        for (auto arg : function_arguments) {
                            param_types.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            param_ids.push_back(arg);
                        }
                        if (!compFunctions(functionTable.at($2.name), $1.type, param_types, param_ids)) {
                            semanticError("Function overloading is not supported");
                        }
                        functionTable[$2.name].startLineImplementation = $4.quad;
                        functionTable[$2.name].isDefined               = true;
                    }
                    else {
                        // New function. Add to the functionTable
                        Function new_func;
                        for (auto arg : function_arguments) {
                            new_func.paramTypes.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            new_func.paramIds.push_back(arg);
                        }
                        new_func.returnType               = $1.type;
                        new_func.startLineImplementation  = $4.quad;
                        new_func.isDefined                = true;
                        new_func.startIndexOptionalParams = -1;
                        functionTable[$2.name]            = new_func;
                    }
                    current_return_type = $1.type;
               }
               |
               TYPE token_id '(' M FUNC_ARGLIST ',' token_ellipsis ')'
               {
                    if (functionTable.find($2.name) != functionTable.end()) {
                        // Function is already defined/declared.
                        if (functionTable[$2.name].isDefined) {
                            semanticError("Redefinition of function \"" + $2.name +"\"");
                        }
                        // else the function is already declared but not defined.
                        vector<string> param_ids;
                        vector<Type> param_types;
                        for (auto arg : function_arguments) {
                            param_types.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            param_ids.push_back(arg);
                        }
                        if (!compFunctions(functionTable.at($2.name), $1.type, param_types, param_ids)) {
                            semanticError("Function overloading is not supported");
                        }
                        functionTable[$2.name].startLineImplementation = $4.quad;
                        functionTable[$2.name].isDefined               = true;
                    }
                    else {
                        // New function. Add to the functionTable
                        Function new_func;
                        for (auto arg : function_arguments) {
                            new_func.paramTypes.push_back(symbolTable[arg].type[0 /*block_depth*/]);
                            new_func.paramIds.push_back(arg);
                        }
                        new_func.returnType               = $1.type;
                        new_func.startLineImplementation  = $4.quad;
                        new_func.isDefined                = true;
                        new_func.startIndexOptionalParams = function_arguments.size();
                        functionTable[$2.name]            = new_func;
                    }
                    current_return_type         = $1.type;
                    current_func_variadic       = true;
                    current_start_index_va_arg  = function_arguments.size();
               }
;

FUNC_ARGLIST : FUNC_ARGLIST ',' DCL
               {
                    current_stack_pointer = 0;
                    // fix argument offset in the symbol table at the current_block_depth
                    reverse(func_args_reversed.begin(), func_args_reversed.end());
                    function_arguments.insert(function_arguments.end(), func_args_reversed.begin(), func_args_reversed.end());
                    for (int i = 0; i < function_arguments.size(); i++) {
                        // iterating ids by the same order they apper in the arg list
                        assert(symbolTable.find(function_arguments[i]) != symbolTable.end());
                        assert(symbolTable[function_arguments[i]].offset.find(current_block_depth) != symbolTable[function_arguments[i]].offset.end());
                        symbolTable[function_arguments[i]].offset[current_block_depth] = (-4) * (i + 2); // stack = [func_return_val (I0-4), 1st_func_arg (I0-8), 2nd_func_arg(I0-12)...]
                    }
                    func_args_reversed.clear();
               }
               |
               DCL
               {
                    current_stack_pointer = 0;
                    // fix argument offset in the symbol table at the current_block_depth
                    reverse(func_args_reversed.begin(), func_args_reversed.end());
                    function_arguments.insert(function_arguments.end(), func_args_reversed.begin(), func_args_reversed.end());
                    for (int i = 0; i < function_arguments.size(); i++) {
                        // iterating ids by the same order they apper in the arg list
                        assert(symbolTable.find(function_arguments[i]) != symbolTable.end());
                        assert(symbolTable[function_arguments[i]].offset.find(current_block_depth) != symbolTable[function_arguments[i]].offset.end());
                        symbolTable[function_arguments[i]].offset[current_block_depth] = (-4) * (i + 2); // stack = [func_return_val (I0-4), 1st_func_arg (I0-8), 2nd_func_arg(I0-12)...]
                    }
                    func_args_reversed.clear();
               }
;

BLK : '{' M_BLK_START STLIST M_BLK_END '}'
      {

      }
;

M_BLK_START:  /*epsilon*/
        {
            current_block_depth++;
            dcl_num_ids = 0;
        }
;

M_BLK_END:  /*epsilon*/
        {
            current_block_depth--;
        }
;


DCL : token_id ':' TYPE
      {
            handleSymbolDcl($1.name, $3.type);
            $$.type = $3.type;
            func_args_reversed.push_back($1.name);
            
      }
      |
      token_id ',' DCL
      {
            handleSymbolDcl($1.name, $3.type);
            $$.type = $3.type;
            func_args_reversed.push_back($1.name);
      }
;

TYPE : token_int
       {
            $$.type = int_;
       }
       | 
       token_float 
       {
            $$.type = float_;
       }
       | 
       token_void
       {
            $$.type = void_t;
       }
;

STLIST : STLIST STMT 
         {

         }
         |
         /*epsilon*/
         { 

         }
;

STMT : DCL ';'
       {
            int stack_pointer_inc_by_bytes = (4 * dcl_num_ids);
            buffer->emit("ADD2I I2 I2 " + intToString(stack_pointer_inc_by_bytes));
            dcl_num_ids = 0;
            func_args_reversed .clear();
       }
       |
       ASSN
       {
            /*do nothing*/
       }
       |
       EXP ';' 
       {
        /*do nothing*/
       }
       |
       CNTRL M
       {
            buffer->backpatch($1.nextList, $2.quad);
       }
       | 
       READ 
       {
        /*do nothing*/
       }
       | 
       WRITE 
       {
        /*do nothing*/
       }
       | 
       RETURN 
       {
        /*do nothing*/
       }
       | 
       BLK
       {    
        /*do nothing*/
       }
;

RETURN : token_return EXP ';'
         {
            if (current_return_type == void_t) {
                semanticError("Return value from void function");
            }
            if (current_return_type != $2.type) {
                semanticError("Return type is not correct");
            }
            // Store the return value in MEM[I1-4]
            string int_float = ($2.type == int_ ? "I" : "F");
            if ($2.type == float_) {
                buffer->emit("CITOF F1 I1");
            }
            buffer->emit("STOR" + int_float + " " + int_float + intToString($2.RegNum) + " " + int_float + "1 -4");
            buffer->emit("RETRN");
         }
         |
         token_return ';'
         {
            buffer->emit("RETRN");
         }
;

WRITE : token_write '(' EXP ')' ';'
        {
            string int_float = ($3.type == int_ ? "I" : "F");
            buffer->emit("PRNT" + int_float + " " + int_float + intToString($3.RegNum));
        }
        |
        token_write '(' token_str ')' ';'
        {
            string str = $3.name;
            for (size_t i = 0; i < str.length(); i++) {
                char ch = str[i];
                if (ch == '\\') {
                    if(str[i+1] == 'n') {
                        ch = '\n';
                    } else if (str[i+1] == 't') {
                        ch = '\t';
                    } else if (str[i+1] == '"') {
                        ch = '\"';
                    }
                    i++;
                }
                buffer->emit("PRNTC " + intToString(static_cast<int>(ch)));
            }
        }
;

READ : token_read '(' LVAL ')' ';'
        {
            // Calc the address of the variable from the base pointer I1
            int address_register = (next_int_register++);
            buffer->emit("ADD2I I" + intToString(address_register) + " I1 " + intToString($3.offset));

            // Use READ and store in temp register
            string int_float   = (($3.type == int_) ? "I" : "F");
            int value_register = ($3.type == int_ ? next_int_register++ : next_float_register++);
            buffer->emit("READ" + int_float + " " + int_float + intToString(value_register));

            if ($3.type == float_) {
                // convert the address_register to float
                int float_address_register = next_float_register++;
                buffer->emit("CITOF F" + intToString(float_address_register) + " I" + intToString(address_register));
                address_register = float_address_register;
            }

            //Store the value in the memory of the LVAL
            buffer->emit("STOR" + int_float + " " + int_float + intToString(value_register) + " " + int_float + intToString(address_register) + " " + intToString(0));
        }
;

ASSN : LVAL token_assign EXP ';'
        {
            // Check types
            if ($1.type != $3.type) {
                semanticError("Try to assign different types");
            }

            // Calc the address of LVAL
            int address_register = (next_int_register++);
            buffer->emit("ADD2I I" + intToString(address_register) + " I1 " + intToString($1.offset)); // Calc the address of the variable from the base pointer I1

            string int_float = (($3.type == int_) ? "I" : "F");

            if ($1.type == float_) {
                // convert the address_register to float
                int float_address_register = next_float_register++;
                buffer->emit("CITOF F" + intToString(float_address_register) + " I" + intToString(address_register));
                address_register = float_address_register;
            }

            // Store the EXP in LVAL memory
            buffer->emit("STOR" + int_float + " " + int_float + intToString($3.RegNum) + " " + int_float + intToString(address_register) + " " + intToString(0));
        }
;

LVAL : token_id
        {
            // Check that id exists in the symbolTable
            if (symbolTable.find($1.name) == symbolTable.end()) {
                semanticError("Undefined variable " + $1.name);
            }
            int token_id_block = current_block_depth;
            if (symbolTable[$1.name].type.find(current_block_depth) == symbolTable[$1.name].type.end()) {
                // exp is defined in upper block
                for (int i = current_block_depth - 1; i >= 0; i--) {
                    if (symbolTable[$1.name].type.find(i) != symbolTable[$1.name].type.end()){
                        token_id_block = i;
                        break;
                    }
                }
            }
            $$.name   = $1.name;
            $$.type   = symbolTable[$1.name].type[token_id_block];
            $$.offset = symbolTable[$1.name].offset[token_id_block];
        }
;

N : /*epsilon*/
    {
        $$.nextList.push_back(buffer->nextQuad());
        buffer->emit("UJUMP "); // to backpatch
    }

M : /*epsilon*/
    {
      $$.quad = buffer->nextQuad();
    }
;

CNTRL : token_if BEXP token_then M STMT token_else N M STMT
        {
            buffer->backpatch($2.trueList, $4.quad);
            buffer->backpatch($2.falseList, $8.quad);
            $$.nextList = merge<int>($5.nextList, $7.nextList);
            $$.nextList = merge<int>($$.nextList, $9.nextList);
        }
        |
        token_if BEXP token_then M STMT
        {
            buffer->backpatch($2.trueList, $4.quad);
            $$.nextList = merge<int>($2.falseList, $5.nextList);
        }
        |
        token_while M BEXP token_do M STMT
        {
            buffer->backpatch($6.nextList, $2.quad);
            buffer->backpatch($3.trueList, $5.quad);
            $$.nextList = $3.falseList;
            buffer->emit("UJUMP " + intToString($2.quad));
        }
;

BEXP : BEXP token_or M BEXP 
       {
            buffer->backpatch($1.falseList, $3.quad);
            $$.trueList  = merge<int>($1.trueList, $4.trueList);
            $$.falseList = $4.falseList;
       }
       |
       BEXP token_and M BEXP
       {
           buffer->backpatch($1.trueList, $3.quad);
           $$.trueList  = $4.trueList;
           $$.falseList = merge<int>($1.falseList, $4.falseList);
       }
       |
       token_not BEXP
       {
           $$.trueList  = $2.falseList;
           $$.falseList = $2.trueList;
       }
       |
       EXP token_relop EXP
       {
            if ($1.type != $3.type) {
                semanticError($2.name + " op is not allowed between different types");
            }

            string relop = $2.name;
            Type type    = $1.type;

            if      (relop == "==") { handleExpRelopExp("SNEQ", "BREQZ", $1.RegNum, $3.RegNum, type, $$.trueList, $$.falseList); }
            else if (relop == "<>") { handleExpRelopExp("SEQU", "BREQZ", $1.RegNum, $3.RegNum, type, $$.trueList, $$.falseList); }
            else if (relop == "<")  { handleExpRelopExp("SLET", "BNEQZ", $1.RegNum, $3.RegNum, type, $$.trueList, $$.falseList); }
            else if (relop == "<=") { handleExpRelopExp("SGRT", "BREQZ", $1.RegNum, $3.RegNum, type, $$.trueList, $$.falseList); }
            else if (relop == ">")  { handleExpRelopExp("SGRT", "BNEQZ", $1.RegNum, $3.RegNum, type, $$.trueList, $$.falseList); }
            else if (relop == ">=") { handleExpRelopExp("SLET", "BREQZ", $1.RegNum, $3.RegNum, type, $$.trueList, $$.falseList); }
       }
       |
       '(' BEXP ')'
       {
            $$ = $2;
       }
;

EXP : EXP token_addop EXP
      {
        if ($1.type != $3.type) {
             semanticError("Try to sum/sub different types");
        }
        Type type        = $1.type;
        $$.type          = type;
        $$.RegNum        = (type == int_ ? next_int_register++ : next_float_register++);
        string int_float = (type == int_ ? "I" : "F");
        string opcode    = ($2.name == "+" ? "ADD2" : "SUBT");
        buffer->emit(opcode + int_float + " " + int_float + intToString($$.RegNum) + " " + int_float + intToString($1.RegNum) + " " + int_float + intToString($3.RegNum));
      }
      |
      EXP token_mulop EXP
      {
        if ($1.type != $3.type) {
            semanticError("Try to mult/div different types");
        }
        Type type        = $1.type;
        $$.type          = type;
        $$.RegNum        = (type == int_ ? next_int_register++ : next_float_register++);
        string int_float = (type == int_ ? "I" : "F");
        string opcode    = ($2.name == "*" ? "MULT" : "DIVD");
        buffer->emit(opcode + int_float + " " + int_float + intToString($$.RegNum) + " " + int_float + intToString($1.RegNum) + " " + int_float + intToString($3.RegNum));
      }
      |
      '(' EXP ')'
      {
        $$ = $2;
      }
      |
      '(' TYPE ')' EXP
      {
        $$.type       = $2.type;
        $$.RegNum     = ($$.type == int_ ? next_int_register++ : next_float_register++);
        if ($$.type == int_) { buffer->emit("CFTOI I" + intToString($$.RegNum) + " F" + intToString($4.RegNum));}
        else                 { buffer->emit("CITOF F" + intToString($$.RegNum) + " I" + intToString($4.RegNum));}
      }
      |
      token_id
      {
        // Check that id exists in the symbolTable
        if (symbolTable.find($1.name) == symbolTable.end()) {
            semanticError("Undefined variable " + $1.name);
        }
        int token_id_block = current_block_depth;
        if (symbolTable[$1.name].type.find(current_block_depth) == symbolTable[$1.name].type.end()) {
            // exp is defined in upper block
            for (int i = current_block_depth - 1; i >= 0; i--) {
                if (symbolTable[$1.name].type.find(i) != symbolTable[$1.name].type.end()){
                    token_id_block = i;
                    break;
                }
            }
        }
        $$.name   = $1.name;
        $$.type   = symbolTable[$1.name].type[token_id_block];
        $$.offset = symbolTable[$1.name].offset[token_id_block];

        // Read the token_id value from memory and store it in register
        int address_register = next_int_register++;
        buffer->emit("ADD2I I" + intToString(address_register) + " I1 " + intToString($$.offset));
        string int_float = ($$.type == int_ ? "I" : "F");
        if ($$.type == float_) {
            // convert the address_register to float
            int float_address_register = next_float_register++;
            buffer->emit("CITOF F" + intToString(float_address_register) + " I" + intToString(address_register));
            address_register = float_address_register;
        }
        $$.RegNum = ($$.type == int_ ? next_int_register++ : next_float_register++);
        buffer->emit("LOAD" + int_float + " " + int_float + intToString($$.RegNum) + " " + int_float + intToString(address_register) + " " + intToString(0));
      }
      |
      NUM
      {
        $$ = $1;
      }
      |
      CALL
      {
        $$.RegNum = $1.RegNum;
        $$.type   =  $1.type;
      }
      |
      VA_MATERIALISE
      {
        $$ = $1;
      }
;

NUM : token_integernum
      {
        $$.type   = int_;
        $$.RegNum = next_int_register++;
        $$.name   = $1.name;
        buffer->emit("COPYI I" + intToString($$.RegNum) + " " + $1.name);
      }
      | 
      token_realnum
      {
        $$.type   = float_;
        $$.RegNum = next_float_register++;
        $$.name   = $1.name;
        buffer->emit("COPYF F" + intToString($$.RegNum) + " " + $1.name);
      }
;

CALL : token_id '(' CALL_ARGS ')'
      {
           if (functionTable.find($1.name) == functionTable.end()) {
               semanticError("Undefined function \"" + $1.name + "\"");
           }

           // Upon a call to variadic function, need to insert code for runtime error.
            if (functionTable.at($1.name).startIndexOptionalParams != (-1)) {
                int index_num_of_va_args = functionTable.at($1.name).startIndexOptionalParams - 1;
                int num_args_regnum = $3.paramRegs[index_num_of_va_args];
                int num_of_given_va_args = $3.paramRegs.size() - functionTable.at($1.name).startIndexOptionalParams;
                
                // HALT if val(num_args_regnum) != num_of_given_va_args
                int tmp_reg = next_int_register++;
                buffer->emit("SNEQI I" + intToString(tmp_reg) + " I" + intToString(num_args_regnum) + " " + intToString(num_of_given_va_args));
                int line_after_halt = buffer->nextQuad() + 2 + runtime_error_msg.length();
                buffer->emit("BREQZ I" + intToString(tmp_reg) + " " + intToString(line_after_halt));
                printRunTimeError();
                buffer->emit("HALT");
            }
            

           // TODO: important to add checks. currently only correct logic is implemented.
            buffer->emit("CITOF F2 I2");
            int max_used_reg = max(next_float_register, next_int_register);
            for (int i=0; i < max_used_reg; i++) {
                buffer->emit("STORI I" + intToString(i) + " I2 " + intToString(i*4));
                buffer->emit("STORF F" + intToString(i) + " F2 " + intToString(i*4));
            }
            // Inc I2 by 4*(max_used_reg + 1)
            int i2_addition = 4 * (max_used_reg + 1);
            buffer->emit("ADD2I I2 I2 " + intToString(i2_addition));
            buffer->emit("COPYI I1 I2"); // base_pointer = stack_pointer
            buffer->emit("CITOF F1 I1");

            // Store function's arguments
            vector<int> param_regs   = $3.paramRegs;
            vector<Type> params_type = $3.paramTypes;
            int current_offset = -8; // Starting from -8 since -4 is reserved for the return value.
            for (int i = 0; i < param_regs.size(); i++) {
                string int_float = (params_type[i] == int_ ? "I" : "F");
                buffer->emit("STOR" + int_float + " " + int_float + intToString(param_regs[i]) + " " + int_float + "1 " + intToString(current_offset - i*4));
            }

            // Update the calling lines of this function
            functionTable[$1.name].callingLines.push_back(buffer->nextQuad());

            // And jump to the function
            Function function = functionTable.at($1.name);
            buffer->emit("JLINK ");

            // At this point we returned from the function.
            buffer->emit("COPYI I2 I1");

            // Save the return value
            int return_value_reg = max_used_reg;//(function.returnType == int_ ? next_int_register++ : next_float_register++);
            next_int_register    = max_used_reg+1;
            next_float_register  = max_used_reg+1;
            string int_float     = (function.returnType == int_ ? "I" : "F");
            if (function.returnType == float_) {
                buffer->emit("CITOF F1 I1");
            }
            buffer->emit("LOAD" + int_float + " " + int_float + intToString(return_value_reg) + " " + int_float + "1 -4");
            $$.RegNum = return_value_reg;
            $$.type   =  function.returnType;

            // Reduce the stack (I2) back and restore the saved registers
            buffer->emit("SUBTI I2 I2 " + intToString(i2_addition));
            buffer->emit("CITOF F2 I2");

            int offset = 0;
            for (int i=0; i < max_used_reg; i++) {
                buffer->emit("LOADI I" + intToString(i) + " I2 " + intToString(i*4));
                buffer->emit("LOADF F" + intToString(i) + " F2 " + intToString(i*4));
            }
      }
;

VA_MATERIALISE : token_va_arg '(' TYPE ',' EXP ')'
                 {
                    if (!current_func_variadic) {
                        semanticError("Call va_arg in non-variadic function");
                    }

                    // Insert code for run-time errors
                    // Need to check that the index of EXP < num of variadic vaiables
                    
                    // First prepare the register of the EXP. convert to int if needed
                    int regnum_offset_in_cells = next_int_register++;
                    int exp_regnum = $5.RegNum;
                    if ($5.type == float_) {
                        // convert float to int
                        int tmp_int_reg = next_int_register++;
                        buffer->emit("CFTOI I" + intToString(tmp_int_reg) + " F" + intToString(exp_regnum));
                        exp_regnum = tmp_int_reg;
                    }

                    // Now read the number of va args from the memory and store in register
                    int num_of_va_args_param_offset = (current_start_index_va_arg + 1) * 4;
                    int num_of_va_arg_regnum = next_int_register++;
                    buffer->emit("LOADI I" + intToString(num_of_va_arg_regnum) + " I1 " + intToString((-1)*num_of_va_args_param_offset));

                    // HALT if index is out of range
                    int sgrt_reg = next_int_register++;
                    buffer->emit("SLETI I" + intToString(sgrt_reg) + " I" + intToString(exp_regnum) + " I" + intToString(num_of_va_arg_regnum));

                    int line_after_halt = buffer->nextQuad() + 2 + runtime_error_msg.length();
                    buffer->emit("BNEQZ I" + intToString(sgrt_reg) + " " + intToString(line_after_halt));
                    printRunTimeError();
                    buffer->emit("HALT");

                    /*
                        Steps to calculate the va_arg value:
                        1. Determine the index at which the va_arg parameters start in the function definition.
                           This can be obtained using (current_start_index_va_arg + 1). Add an additional +1 to account for the return value.
                        2. Multiply the calculated index by 4 to get the offset in bytes. Note that the offset remains positive at this stage.
                        3. Calculate the actual offset from I1 (a negative value) by subtracting the computed offset from 0.
                        4. At this point, we have the real offset of the required va_arg, which can now be read from memory. Perform type casting as necessary based on the type of the required va_arg.
                        5. If needed, cast I1 to a float register.
                        6. Load the va_arg from memory using the LOAD command.
                    */

                    // TODO: add any needed checks.

                    /* Step 1 */
                    int va_arg_offset_cells = (current_start_index_va_arg + 2); // [ret_val, arg1, arg2, ... 1st_va_arg]
                    int regnum_total_offset_in_cells = ($5.type == int_ ? next_int_register++ : next_float_register++);
                    string int_float  = ($5.type == int_ ? "I" : "F");
                    buffer->emit("ADD2" + int_float + " " + int_float + intToString(regnum_total_offset_in_cells) + " " + int_float + intToString($5.RegNum) + " " + intToString(va_arg_offset_cells) + ($5.type == int_ ? "" : ".0"));
                    
                    /* Step 2 */
                    int regnum_total_abs_offset_in_bytes = ($5.type == int_ ? next_int_register++ : next_float_register++);
                    buffer->emit("MULT" + int_float + " " + int_float + intToString(regnum_total_abs_offset_in_bytes) + " " + int_float + intToString(regnum_total_offset_in_cells) + " " + ($5.type == int_ ? "4" : "4.0"));

                    /* Step 3 */
                    int regnum_total_real_offset_in_bytes = ($5.type == int_ ? next_int_register++ : next_float_register++);
                    buffer->emit("SUBT" + int_float + " " + int_float + intToString(regnum_total_real_offset_in_bytes) + " " + ($5.type == int_ ? "0" : "0.0") + " " + int_float + intToString(regnum_total_abs_offset_in_bytes));
                    
                    /* Step 4 */
                    if (($3.type == int_) && ($5.type == float_)) {
                        int int_reg = next_int_register++;
                        buffer->emit("CFTOI I" + intToString(int_reg) + " F" + intToString(regnum_total_real_offset_in_bytes));
                        regnum_total_real_offset_in_bytes = int_reg;
                    } else if (($3.type == float_) && ($5.type == int_)) {
                        int float_reg = next_float_register++;
                        buffer->emit("CITOF F" + intToString(float_reg) + " I" + intToString(regnum_total_real_offset_in_bytes));
                        regnum_total_real_offset_in_bytes = float_reg;
                    }

                    /* Step 5 */
                    int base_reg = 1; // I1
                    if ($3.type == float_) {
                        int base_reg_float = next_float_register++;
                        buffer->emit("CITOF F" + intToString(base_reg_float) + " I1");
                        base_reg = base_reg_float;
                    }

                    /* Step 6 */
                    int_float = ($3.type == int_ ? "I" : "F");
                    int final_reg = ($3.type == int_ ? next_int_register++ : next_float_register++);
                    buffer->emit("LOAD" + int_float + " " + int_float + intToString(final_reg) + " " + int_float + intToString(base_reg) + " " + int_float + intToString(regnum_total_real_offset_in_bytes));

                    $$.type   = $3.type;
                    $$.RegNum = final_reg;
                 }
;

CALL_ARGS : CALL_ARGLIST 
            {
                $$.paramRegs  = $1.paramRegs;
                $$.paramTypes = $1.paramTypes;
            }
            |
            /*epsilon*/
            {
                /*do nothing*/
            }
;

CALL_ARGLIST : CALL_ARGLIST ',' EXP
               {
                    $$.paramRegs  = $1.paramRegs;
                    $$.paramTypes = $1.paramTypes;
                    $$.paramRegs.push_back($3.RegNum);
                    $$.paramTypes.push_back($3.type);
               }
               |
               EXP
               {
                    $$.paramRegs.push_back($1.RegNum);
                    $$.paramTypes.push_back($1.type);
               }
;

%%

/* Helper methods */

void handleSymbolDcl(string name, Type type) {
    // void_t is not a valid symbol type
    if (type == void_t) {
        semanticError(name + " declared as void");
    }
    // Check if symbol already exists
    if (symbolTable.find(name) != symbolTable.end()) {
        // Symbol exist. Need to check if the same scope.
        Symbol sym = symbolTable.at(name);
        if (sym.type.find(current_block_depth) != sym.type.end()) {
                semanticError("variable \"" + name + "\" is already declared previously. Redefinition");
        }
        
        // New symbol. Add to the map.
        sym.type[current_block_depth]   = type;
        sym.offset[current_block_depth] = current_stack_pointer;
        sym.depth                       = max(sym.depth, current_block_depth);
        current_stack_pointer           += 4;
    } else {
        // Symbol doesn't exist. Create a new one.
        Symbol new_symbol;
        new_symbol.type[current_block_depth]   = type;
        new_symbol.offset[current_block_depth] = current_stack_pointer;
        new_symbol.depth                       = current_block_depth;
        symbolTable[name]                      = new_symbol;
        current_stack_pointer                  += 4;
    }
    dcl_num_ids++;
}

void handleExpRelopExp(string opcode_without_type, string opcode_breqz_bneqz, int exp1_regnum, int exp2_regnum, Type type, vector<int>& true_list, vector<int>& false_list) {
    string int_float = (type == int_ ? "I" : "F");
    int tmp_register = (type == int_ ? next_int_register++ : next_float_register++);
    buffer->emit(opcode_without_type + int_float + " " + int_float + intToString(tmp_register) + " " + int_float + intToString(exp1_regnum) + " " + int_float + intToString(exp2_regnum));
    int branch_register = tmp_register;
    if (type == float_) {
        // BREQZ works on int register, need to convert float to int.
        branch_register = next_int_register++;
        buffer->emit("CFTOI I" + intToString(branch_register) + " F" + intToString(tmp_register));
    }
    true_list.push_back(buffer->nextQuad());
    buffer->emit(opcode_breqz_bneqz + " I" + intToString(branch_register) + " ");
    false_list.push_back(buffer->nextQuad());
    buffer->emit("UJUMP ");
}

void printRunTimeError() {
    for (int i = 0; i < runtime_error_msg.length(); i++) {
        buffer->emit("PRNTC " + intToString(static_cast<int>(runtime_error_msg[i])));
    }
}

bool compFunctions(const Function& func, Type return_type, vector<Type> param_types, vector<string> param_ids) {
    if (!(func.returnType == return_type)) {
        return false;
    }

    if (func.paramTypes != param_types) {
        return false;
    }

    if (func.paramIds != param_ids) {
        return false;
    }

    return true;
}


int main(int argc, char* argv[]) {

   if (argc != 2 ){
      cerr << "A single .cmm file should be provided.\nUsage: rx-cc <input_file_name>.cmm" << endl;
      return OPERATIONAL_ERROR;
   }

   string cmm_file = argv[1];
   if (cmm_file.find(".cmm") == string::npos) {
      cerr << "The provided file must be a .cmm file" << endl;
      return OPERATIONAL_ERROR;
   }

   extern FILE *yyin;
   yyin = fopen(cmm_file.c_str(), "r");
   if (!yyin) {
      cerr << "Couldn't open the provided file: " << cmm_file << endl;
      return OPERATIONAL_ERROR;
   }

   // Initialize the buffer global pointer
   Buffer program_buffer;
   buffer = &program_buffer;

   // Run the Parser
   yyparse();

   // Create the .rsk file 
   ofstream rsk_file(cmm_file.substr(0,cmm_file.find(".cmm")) + ".rsk");
   if (!rsk_file.is_open()) {
      cerr << "Couldn't create .rsk file" << endl;
      return OPERATIONAL_ERROR;
   }

   // Add header to the buffer
   
   buffer->frontEmit("</header>");

   ostringstream implemented;
   ostringstream unimplemented;
   implemented   << "<implemented>";
   unimplemented << "<unimplemented>";

   for(auto func_pair : functionTable) {
       if (func_pair.second.isDefined) {
           implemented << " " << func_pair.first << "," << intToString(func_pair.second.startLineImplementation);
       } else {
           unimplemented << " " << func_pair.first;
           for (auto calling_line : func_pair.second.callingLines) {
               unimplemented << "," << intToString(calling_line);
           }
       }
   }

   buffer->frontEmit(implemented.str());
   buffer->frontEmit(unimplemented.str());
   buffer->frontEmit("<header>");

   rsk_file << buffer->printBuffer();
   rsk_file.close();

   return 0;
}

/*** Errors handling ***/

void yyerror(const char* c)
{
    cerr << "Syntax error: " <<  yytext << " in line number " << yylineno << endl;
    exit(SYNTAX_ERROR);
}

void semanticError(string str)
{
    cerr << "Semantic error: " << str << " in line number " << yylineno << endl;
    exit(SEMANTIC_ERROR);
}


/*** For debug only ***/

void DBG(string str) {
    cout << "***DBG*** " << str << endl;
}

void DbgPrintAllFunctions() {
    for (const auto& func : functionTable) {
        cout << "\n\n" << endl;
        cout << "Function: " << func.first << endl;

        cout << "startLineImplementation: " << func.second.startLineImplementation << endl;
        
        // Print paramTypes
        cout << "Parameter Types: ";
        for (auto type : func.second.paramTypes) {
            cout << intToString(type) << " ";
        }
        cout << endl;

        // Print paramIds
        cout << "Parameter IDs: ";
        for (auto id : func.second.paramIds) {
            cout << id << " ";
        }
        cout << endl;
    }
}
